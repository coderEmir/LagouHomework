/**
 * 1. 作用域问题
 */
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]()
/**
 * 解答：
 * 输出结果：10
 * 原因：var 声明的变量，没有作用域限制
 */

 /**
  * 2. let
 */
var tmp = 123
if (true) {
    console.log(tmp);
    // let tmp
}
/**
 * 解答：
 * 输出结果：报错 ReferenceError: Cannot access 'tmp' before initialization
 * let声明的成员，没有变量声明的提升功能
 */

 /**
  * 3. 找出数组最小值
  */
 var arr = [12, 34, 32, 89, 4]
var minNum = Math.min(...arr)
console.log(minNum);

/**
 * 4. 声明成员变量修饰符比较
 */
// var 
//     可实现变量声明的提升，JS只有函数作用域和全局作用域，在声明变量之前调用，返回undefined，用法上不够严谨

// let
//     let声明的成员，删除变量声明的提升功能，只能在其块级作用域中被访问到

// const
//     const声明的成员是只读的，只能修改const声明变量的内容，不能改变变量内存地址。
//     全局 const声明的变量不会挂载到windows上。因为没有块级作用域环境。

/**
 * 5. this
 */
var a = 10
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}

obj.fn()
/**
 * 输出结果：20
 * 原因：this 取决于调用方式，当前作为方法调用，调用者为obj实例对象，this则指向obj实例对象
 */

 /**
  * 6. Symbol
  * 用于表示对象的一个独一无二的属性名，例如避免对象属性扩展时覆盖
  */

  /**
   * 7. 拷贝
   * 浅拷贝：拷贝的是对象地址，拷贝结果是多个指向同一内存地址的指针
   * 深拷贝：拷贝的是对象本身，拷贝结果是在内存中开辟新的内存空间，存储一份相同的对象
   */

   /**
    * 8. TS与JS
    * TS是JS的超集，TS保留JS特性，并增加了静态类型、类、模块、接口和类型注解方面的功能，更适合开发大型项目
    */

    /**
     * 9.TS优缺点
     * 优点：
     *      兼容性好，可以快速上手
     *      安全性高，可以在编译阶段解决很多错误
     *      社区活跃，很多优秀的框架都有相关类型定义文件
     * 缺点：
     *      对于没有接触过高级语言的人，还是有一定的学习成本
     *      有些库还没有很好的支持TS
     */

    /**
     * 10. 引用计数器
     * 工作原理：对象被创建，或者有新的指针指向对象时，引用计数器会 +1，
     * 减少一次引用，计数器的值 -1，当对象不再被引用时，引用计数器的值为 0
     * 优点：实时性。一旦没有引一用，内存就直接释放了。
     * 缺点：
     *      维护引计数消耗资源。
     *      循环引用。
     */

     /**
      * 11. 标记整理算法
      * 工作流程：
      * - 将当前活动的可达对象进行标记
      * - 执行内存整理，移动可达对象位置，成为连续内存
      * - 回收可达对象以外的内存
      */

      /**
       * 12. V8中新生代存储区垃圾回收流程
       * - 将空间一分为二，小空间存储新生代对象，新生代内存区也分为两个大小的空间：from 和 To
       * - 将活动对象存储在From中
       * - 将from中的数据，标记整理后，复制到To中
       * - from和 To 交换空间，释放原from的内存占用
       * - 当一轮CG后还存活的新生代，需要晋升到老生代
       * - To空间使用率超过25%时，也会出现晋升
       */

       /**
        * 13. 增量标记算法
        * 使用：
        * - 系统会优先使用标记清除，当内存碎片不能够满足新生代移动所需存储需求时，系统会使用标记整理，在需要分步处理垃圾回收时，采用增量标记
        * 工作原理：
        * - 提升回收内存垃圾效率，增量标记采用分段处理方式，将垃圾回收操作与js代码执行过程交替处理，在特定时间完成一次清除
        */
